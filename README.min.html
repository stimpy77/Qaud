<h1>QAUD (Query Add Update Delete) v0.2</h1><p><sub><sup>(QAUD is not a word. Don't fix it.)</sup></sub><br> QAUD is an interface plus implementations for QAUD, or CRUD, operations. <br> It's ICrud, basically, intended for extending IQueryable-supporting data repositories with the promise of a <br> basic set of alteration operations.</p><h2>Supported Implementations</h2><ul><li><strong>EntityFramework is passing initial very basic tests.</strong></li><li><strong>RavenDB is passing initial very basic tests.</strong></li><li><strong>A DataTable implementation is passing initial very basic tests.</strong></li><li><strong>A SortedDictionary implementation is passing initial very basic tests.</strong></li><li>Other ORMs and data repositories are yet to be added.</li></ul><h2>Background</h2><p>The objective behind QAUD is to facilitate a DAL (Data Access Layer) into prototype applications that do not know<br> the full measure of the technology behind the DAL. Most DALs start with key-based table or document structures, so this <br> solution builds upon that premise.</p><p>For example, someone implementing a dynamic web site, such as an online store, might use <code>IDataStore&lt;T&gt;</code> for all<br> data storage operations because he might not know whether the deployed solution will build upon MongoDB, MySQL, <br> SQL Server, or some other server. By using <code>IDataStore&lt;T&gt;</code> for all DAL, the prototype solution can switch the <br> underlying database, NoSQL, or in-memory data storage implementation by only changing the IoC/DI initializer, <br> assuming <code>IDataStore&lt;T&gt;</code> has been generically implemented for the chosen actual database implementation.</p><p>Building applications upon <code>IDataStore&lt;T&gt;</code> would only be recommended for accelerating <strong>prototype application <br> development</strong> or for applications where <strong>DAL performance is less important than DAL targeting versatility</strong>.<br> An enterprise environment that is heavily dependent upon the Microsoft stack, including SQL Server, would not<br> benefit from <code>IDataStore&lt;T&gt;</code> as much as a development team or individual that is</p><p>Another situation is where an application that builds entirely upon <code>IDataStore&lt;T&gt;</code>, or at least upon <br> <code>ICrud&lt;T&gt;</code>/<code>ICrudEx&lt;T&gt;</code>, can utilize in-memory implementations when implementing functional tests.</p><h2><code>ICrud&lt;T&gt;</code> has come at last.</h2><p>The base interface is <code>ICrud&lt;T&gt;</code>; the following summarizes it:</p><pre><code>    public interface ICrud&lt;T&gt; : ICreate&lt;T&gt;, 
                                IAddItem&lt;T&gt;, 
                                IFind&lt;T&gt;, 
                                IUpdate&lt;T&gt;, 
                                IDelete
    {
    /* implemented by above declaration:

        T     Create ();
        void  Add    (T item);
        T     Find   (params object[] key);
        void  Update (T item);
        void  Delete (params object[] key);
    */
    }
</code></pre><p>.. plus extensions in <code>ICrudEx&lt;T&gt;</code> for common variations and convenience operations.</p><h2>Full Generic Repository Interface</h2><p>The complete interface for a repository is <code>IDataStore&lt;T&gt;</code>; the following summarizes it:</p><pre><code>    public interface IDataStore&lt;T&gt; : ICrudEx&lt;T&gt;, IHasQueryable&lt;T&gt;
    {

    /*  ICrudEx&lt;T&gt; includes these:

        T Create();
        void Add(T item);
        void Add(T item, out T result);
        void AddRange(IEnumerable&lt;T&gt; items);
        T FindMatch(T lookup);
        T Find(params object[] keyvalue);
        void Update(T item);
        void UpdateRange(IEnumerable&lt;T&gt; items);
        T UpdatePartial(object item);
        void Delete(params object[] keyvalue);
        void DeleteItem(T item);
        void DeleteRange(IEnumerable&lt;T&gt; items);

    */

    /*  IHasQueryable&lt;T&gt; includes this:

        IQueryable&lt;T&gt; Query { get; }
    */


        // if false, defers changes; false not always supported, see CanQueueChanges
        bool AutoSave { get; set; }

        // apply changes; noop if AutoSave == true
        void SaveChanges();

        // indicates whether AutoSave can be set to false
        void CanQueueChanges();

        // indicates support for "navigation properties" as with EF
        bool SupportsNestedRelationships { get; } 

        // indicates support for multilevel object graphs in one entry as with RavenDB
        bool SupportsComplexStructures { get; }

        // indicates support for [DatabaseGenerated(Identity)] 
        bool SupportsGeneratedKeys { get; }

        // indicates support for using(var scope = new TransactionScope()) { .. }
        bool SupportsTransactionScope { get; }

        // gets the underlying data table, data set, dictionary, or whatever is doing the work
        object DataSet { get; }

        // gets the object that contains the connection, if any, to the database
        object DataContext { get; }
    }
</code></pre><p>Note: Most of these non-CRUD support members explicitly declared on <code>IDataStore&lt;T&gt;</code> should be implemented <br> explicitly, to conveniently hide from consumer code (i.e. from intellisense).</p><hr><p>A few usage notes:</p><ol><li>IDataStore[T] is a generic interface to a repository as a <em>table structure</em>, <em>document structure</em>, or similar, not a schema / database.</li><li><em><strong>The [System.ComponentModel.DataAnnotations.Key] attribute is required on at least one member of T in IDataStore[T].</strong></em></li><li>Any provider must support LINQ. The purpose of Qaud is to add <code>Add</code>, <code>Update</code>, and <code>Delete*</code> commands (plus some helpful touches such as <code>UpdatePartial()</code>) to IQueryable in a common and useful interface.</li><li>Provider implementations should ideally "hide" support members: <code>DataSetImplementation</code>, <code>DataContextImplementation</code>, <code>SupportsNestedRelationships</code>, <code>SupportsTransactionScope</code>, and <code>SupportsComplexStructures</code>. These are not interesting repository properties/methods for a repository interface consumer, but they are on the interface for identifying implementation behaviors, when you need to know them.</li><li>Some features require reflection, such as <code>UpdatePartial()</code>, which is like <code>Update()</code> but takes any object that has the same key field(s) and that has only the properties potentially containing changes. If you do not want to utilize any feature that uses reflection, do not use data provider implementations that impose it, and avoid these special interface member(s).</li></ol>